*操作系统*
- [定义](#定义)
- [内容](#内容)
  - [概念](#概念)
  - [硬件](#硬件)
  - [内存](#内存)
  - [多任务](#多任务)
  - [网络](#网络)
  - [文件系统](#文件系统)
- [应用](#应用)

# 定义 #
操作系统是管理计算机硬件与软件资源的计算机程序

# 内容 #
## 概念 ##
```
并发&并行
- 并发  多个事件交替发生在一个实体上
- 并行  多个事件同时发生在多个实体上

同步&异步
- 同步  当一个调用发出后，调用者一直等待返回结果，才能进行后续的执行
- 异步  当一个调用发出后，调用者不用等待返回结果，处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者

阻塞&非阻塞
- 阻塞  调用结果返回前，暂时停止运行
- 非阻塞  调用结果返回前，不会停止运行

内核态&用户态(cpu特权模式)
CPU都有几种不同的指令执行级别，linux使用了0级和3级分别来表示内核态和用户态
- 内核态  内核态可以访问任意的数据，包括外围设备，占用CPU不会发生抢占情况
- 用户态  用户态只能受限的访问内存，并且不允许访问外围设备，用户态下的CPU不允许独占，CPU能够被其他程序获取

CPU
-CPU使用率
-CPU负载 
```
## 硬件 ##
```
冯诺依曼模型
- 运算器
- 控制器
- 存储器
- 输入设备
- 输出设备

总线
- 地址总线  用于指定CPU将要操作的内存地址
- 数据总线  用于读写内存的数据
- 控制总线  用于发送和接收信号

CPU执行过程
- CPU读取程序计数器的值，将指令数据存入到指令寄存器
- 程序计数器的值自增
- CPU分析指令寄存器中的指令

存储器
- 寄存器
- L1-Cahce(单独, 数据和指令分开)
- L2-Cahce(单独)
- L3-Cahce(共用)
- 内存
- 硬盘

提高CPU缓存命中率
- 提升数据的缓存命中率
  按照内存布局顺序访问
- 提升指令缓存的命中率  
  利用CPU的分支预测器，提前缓存指令
- 提升多核CPU的缓存命中率
  线程绑定在某一个CPU核心上
```

## 内存 ##
```
虚拟内存
作用
物理内存不能隔离进程，地址容易被覆盖，造成程序崩溃  
虚拟地址会通过CPU芯片中的内存管理单元(MMU)的映射关系来转换变成物理地址
分类
- 内核空间
- 用户空间
分配方式
- 分段
  虚拟地址  段选择因子和段内偏移量(段表)
  优点
  - 便于管理
  缺点
  - 内存碎片
  - 内存交换的效率低
- 分页
  虚拟地址  页号和页内偏移量(页表)
  缺点
  - 页表过大
  解决
  - 多级页表
  - 页表缓存
- 段页式

页面置换算法
- 最佳页面置换算法
  置换在未来最长时间不访问的页面
- 先进先出置换算法
  选择在内存驻留时间最长的页面进行中置换
- 最近最久未使用的置换算法
  选择最长时间没有被访问的页面进行置换  
- 最不常用算法
  选择访问次数最少的那个页面进行置换
- 时钟页面置换算法
  把所有的页面都保存在一个类似钟面的环形链表中，一个表针指向最老的页面  
  当发生缺页中断时，算法首先检查表针指向的页面
  如果它的访问位是0就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置
  如果访问位是1就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为0的页面为止
```

## 多任务 ##
```
进程
概念
进程是资源分配的基本单位
状态
- 创建状态
- 就绪状态
- 就绪挂起
- 运行状态
- 阻塞状态
- 阻塞挂起
- 结束状态
控制
- 创建进程
- 终止进程
- 阻塞进程
- 唤醒进程
上下文切换
- 地址空间资源
- 内核栈切换
- 硬件上下文切换

进程间通信 
- 管道
  主要用于同步处理，即管道的两端必须要有一个进程在写入数据，另一个进程在读取数据
  管道可以分为pipe(无名管道)和fifo(命名管道)两种  
  管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据  
  管道是一种半双工的通信方式，数据只能在一个方向上流动
  - 无名管道
    只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系
  - 命名管道
    任何进程有相应的权限都可以对它进行访问
- 消息队列
  异步，支持多个生产者和多个消费者
  是一系列保存在内核中消息的列表
- 共享内存
  共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中
- 信号
- 信号量
  主要作为进程之间及同一种进程的不同线程之间的同步和互斥手段，它常作为一种锁机制
- SOCKET

调度算法
- 先来先服务调度算法
  每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行
- 最短作业优先调度算法
  优先选择运行时间最短的进程来运行
- 时间片轮转调度算法
  每个进程被分配一个时间段，称为时间片，即允许该进程在该时间段中运行
- 高响应比优先调度算法
  每次进行进程调度时，先计算响应比优先级，然后把响应比优先级最高的进程投入运行
- 最高优先级调度算法
  从就绪队列中选择最高优先级的进程进行运行
- 多级反馈队列调度算法
  - 多级  表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短
  - 反馈  表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列

线程
线程是调度执行(CPU调度)的基本单位

协程
用户态的执行单元

锁
死锁
由于系统中存在一些不可剥夺资源，而当两个或两个以上进程占有自身资源，并请求对方资源时，会导致每个进程都无法向前推进，这就是死锁
死锁产生的必要条件
- 互斥条件  在一段时间内某资源仅为一进程所占用
- 请求和保持条件  当进程因请求资源而阻塞时，对已获得的资源保持不放
- 不剥夺条件  进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放
- 循环等待条件  存在一个封闭的进程链，使得每个进程至少占有此链中下一个进程所需要的一个资源
分类
- 读写锁
- 互斥锁
- 自旋锁
  如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止
```

## 网络 ##
```
文件IO
- 缓冲I/O，利用的是标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件
- 非缓冲I/O，直接通过系统调用访问文件，不经过标准库缓存
- 直接I/O，不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘
- 非直接I/O，读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘
- 阻塞I/O  阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程
- 非阻塞I/O  非阻塞等待的是「数据从内核态拷贝到用户态」
- 同步I/O  「内核数据准备好」或「数据从内核态拷贝到用户态」这两个过程需要等待
- 异步I/O  是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程都不用等待

IO多路复用
- 目的  
  多路复用减少线程数量，从而减少线程切换次数，提高CPU利用率  
- 思想
  在获取事件时，先把所有连接(文件描述符)传给内核，再由内核返回产生了事件的连接，然后在用户态中再处理这些连接对应的请求即可
- 实行
  - select
    select实现多路复用的方式是，将已连接的Socket都放到一个文件描述符集合，然后调用select函数将文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过遍历文件描述符集合的方式，当检查到有事件产生后，将此Socket标记为可读或可写，接着再把整个文件描述符集合拷贝回用户态里，然后用户态还需要再通过遍历的方法找到可读或可写的Socket，然后再对其处理。
    所以，对于select这种方式，需要进行2次「遍历」文件描述符集合，一次是在内核态里，一个次是在用户态里 ，而且还会发生2次「拷贝」文件描述符集合，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中
    select使用固定长度的BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的
  - poll
    poll不再用BitsMap来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了select的文件描述符个数限制
  - epoll
    在内核里使用红黑树来跟踪进程所有待检测的文件描述符
    使用事件驱动的机制，内核里维护了一个链表来记录就绪事件

文件传输
- 小文件
  - read+write
    - 过程 
      - read
        - 用户态切到内核态
        - 通过DMA把文件从磁盘拷贝到内核缓冲区
        - 通过CPU把文件从内核缓冲区拷贝到用户缓冲区
        - 内核态切换到用户态
      - write
        - 用户态切换到内核态
        - 通过CPU把文件从用户缓冲区拷贝到socket缓冲区
        - 通过DMA把文件从socket缓冲区拷贝到网卡
        - 内核态切换到用户态
      四次上下文切换，四次数据拷贝
  - mmap+write
    - 实现
      mmap+write  mmap()系统调用函数会直接把内核缓冲区里的数据「映射」到用户空间
    - 过程
      - mmap
        - 用户态切到内核态
        - 通过DMA把文件从磁盘拷贝到内核缓冲区
        - 内核态切换到用户态
      - write
        - 用户态切换到内核态
        - 通过CPU把文件从内涵缓冲区拷贝到socket缓冲区
        - 通过DMA把文件从socket缓冲区拷贝到网卡
        - 内核态切换到用户态
      四次上下文切换，三次数据拷贝
  - sendfile
    - 实现
      sendfile()系统调用，可以直接把内核缓冲区里的数据拷贝到socket缓冲区里
    - 过程
      - 用户态切到内核态
      - 通过DMA把文件从磁盘拷贝到内核缓冲区
      - 通过CPU把文件从内核缓冲区拷贝到socket缓冲区
      - 通过DMA把文件从socket缓冲区拷贝到网卡
      - 内核态切换到用户态
      两次上下文切换，三次数据拷贝
  - sendfile+SG-DMA
    - 实现
      把内核缓冲区数据描述符和数据长度传到socket缓冲区，网卡的SG-DMA控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里
    - 过程
      - 用户态切到内核态
      - 通过DMA把文件从磁盘拷贝到内核缓冲区
      - 通过SG-DMA把文件从内核缓冲区拷贝到网卡
      - 内核态切换到用户态
      两次上下文切换，两次数据拷贝
    - 应用
      - Kafka
- 大文件  
  - 直接I/O+异步I/O
    绕开PageCache的I/O叫直接I/O，使用PageCache的I/O则叫缓存I/O

```

## 文件系统 ##
```
文件的描述
- 索引节点  也就是inode，用来记录文件的元信息，占用磁盘空间
- 目录项  也就是dentry，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系，不存放于磁盘，缓存在内存  
目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件

文件的层次
- 用户程序，包括库函数
- 系统调用
- 虚拟文件系统(目录项缓存，索引节点缓存，页缓存)
- 文件系统
- 缓存区Buffer
- 本地磁盘设备

文件的存储
- 连续空间存放
  文件头 起始块位置+长度
- 非连续空间存放
  - 链表方式
    隐式链表
    显示链表
  - 索引方式

空闲空间管理
- 空闲表
- 空闲链表
- 位图法

文件系统结构
- 引导块
- 块组
  - 超级块  文件系统的状态
  - 块组描述符  文件系统中各个块组的状态
  - 数据位图
  - inode位图
  - inode列表
  - 数据块

软链接和硬链接
- 硬链接是多个目录项中的「索引节点」指向一个文件
- 软链接相当于重新创建一个文件，这个文件有独立的inode，但是这个文件的内容是另外一个文件的路径
```

# 应用 #
```
快捷键
- `ctrl c`  终止当前命令
- `ctrl z`  暂停当前命令
- `fg`  继续前台执行
- `bg`  继续后台执行
- `ctrl l`  清屏
- `ctrl a`  跳转到输入首部
- `ctrl e`  跳转到输入尾部

关机&重启
- `shutdown -h time`  关机
- `shutdown -r time`  重启
- `reboot`  重启

目录
- `cd path`  切换
  cd ~|cd -
- `ls path`  查看
  ls | la -a | ls -l
- `mkdir`  创建目录
  mkdir -m | mkdir -p 
- `rm -rf`  删除目录
- `rmdir`  删除空目录
  rmdir -p  
- `mv`  剪切目录
- `cp`  拷贝目录
- `find directory option pattern command`  文件查找
- `touch file file`  创建文件
- `rm file`  删除文件
- `vim file`  修改文件
- `cat file`  查看文件 
- `tac file`  查看文件
- `head option pattern file file`  查看文件开头部分
- `tail option pattern file file`  查看文件结尾部分
- `chmod [u|g|o|a] [+|-|=] [r|w|x] directory|file`
- `tar -zcvf *.tar.gz directory|file`  打包文件
- `tar -zxvf *.tar.gz -C directory`  解包文件

查找
- `grep option pattern file`  文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来
  -A x  除了显示符合样式的那一列之外，并显示该行之后的x行内容
  -B x  除了显示符合样式的那一行之外，并显示该行之前的x行内容
  -C x  除了显示符合样式的那一行之外，并显示该行之前后的x行内容
  -c  统计匹配的行数
  -e  实现多个选项间的逻辑or关系
  -E  扩展的正则表达式
  -f file  从文件获取PATTERN匹配
  -F  相当于fgrep，PATTERN被当作固定字符串
  -i  忽略字符大小写的差别
  -n  显示匹配的行号
  -o  仅显示匹配到的字符串
  -q  静默模式，不输出任何信息
  -s  不显示错误信息。
  -v  显示不被pattern匹配到的行，相当于[^]反向匹配
  -w  匹配整个单词  
- `sed [-hnV][-e<script>][-f<script文件>] file`  利用脚本来处理文本文件
  -e<script>  以选项中指定的script来处理输入的文本文件，这个-e可以省略，直接写表达式
  -f<script文件>  以选项中指定的script文件来处理输入的文本文件
  -h  显示帮助
  -n  仅显示script处理后的结果
  -V  显示版本信息
  i  插入  i的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)
  a  新增  a的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)
  d  删除  因为是删除啊，所以d后面通常不接任何东西
  c  取代  c的后面可以接字串，这些字串可以取代n1,n2之间的行
  s  取代  替换单个字符，通常这个s的动作可以搭配正规表示法，例如1,20s/old/new/g
  p  打印  将某个选择的数据印出，通常p会与参数sed -n一起运行
- `awk option [<script>] [-f<scriptfile>] var=value file`  文本分析
  option
    -F fs  fs指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，默认是空格或者tab键
  变量
    FILENAM  当前文件名
    FS  字段分隔符，默认是空格和制表符
    RS  行分隔符，用于分割每一行，默认是换行符
    OFS  输出字段的分隔符，用于打印时分隔字段，默认为空格
    ORS  输出记录的分隔符，用于打印时分隔记录，默认为换行符
    NF  总字段数量
    NR  当前行
  函数
    toupper()  字符转为大写
    tolower()  字符转为小写
    length()  返回字符串长度
    substr()  返回子字符串

排序
- `sort option` 
  -n 按数字进行排序 
  -d 按字典序进行排序
  -r 逆序排序
  -k N 指定按第N列排序

去重
- `uniq`
  -c  统计各行在文件中出现的次数
  -d  找出重复行

统计
- `wc`
  -l  统计行数
  -w  统计单词数
  -c  统计字符数

命令行参数转换
- `xargs options command`
  -d  定义定界符(默认为空格 多行的定界符为n)
  -L  从标准输入一次读取num行送给command命令
  -n  表示命令在执行的时候一次用的argument的个数，默认是用所有的
  -I  将xargs的每项名称赋值给{}，可以用{}代替

其它
- `ssh username@ip`  远程登录
- `ping domain|ip`  网络检测
- `wget url`  文件下载
- `su -username`  切换用户
- `netstat -tln | grep port`  查看端口使用情况
- `lsof -i :port`  查看端口属于程序
```

参考资料  
![Golang修养之路](https://github.com/aceld/golang)