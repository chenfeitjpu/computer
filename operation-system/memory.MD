**内存管理**
- [内容](#内容)
  - [虚拟内存](#虚拟内存)
    - [简介](#简介)
    - [内存分段](#内存分段)
    - [内存分页](#内存分页)
    - [段页式内存管理](#段页式内存管理)
    - [Linux内存布局](#linux内存布局)
  - [内存分配](#内存分配)
  - [内存回收](#内存回收)

# 内容 #
## 虚拟内存 ##
### 简介 ###
**为什么要有虚拟内存**  
- 虚拟内存可以使得进程运行内存超过物理内存大小
- 页表是私有的，解决了多进程之间地址冲突
- 页表有一些标记属性的比特，比如控制一个页的读写权限，提供了更好的安全性

**实现**  
![](./images/memory/virtual.webp)

### 内存分段 ###  
**结构**  
![](./images/memorty/segment.webp)

**组成**  
- 段选择因子
- 段内偏移量

**问题**  
- 内存碎片化
- 内存交换效率低

### 内存分页 ###
**结构**
![](./images/memory/page.webp)

**组成**  
- 页号
- 页内偏移

**问题**  
- 页表占用空间大
 
**多级页表**  
*二级分页*  
![](./images/memory/two_page_table.webp)

*四级分页*  
![](./images/memory/four_page_table.webp)

*TLB*  
存放程序最常访问的页表项

### 段页式内存管理 ###
**结构**  
![](./images/memory/segment_page.webp)

**地址变换**
- 访问段表，得到页表起始地址
- 访问页表，得到物理页号
- 物理页号与页内位移组合，得到物理地址

### Linux内存布局 ###
**Intel处理器内存布局**  
![](./images/memory/intel.webp)

**Linux内存**  
Linux系统中的每个段都是从0地址开始的整个4GB虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的

## 内存分配 ##
**malloc**  
- 内存小于128KB, 通过brk()系统调用从堆分配内存  
  free释放内存的时候，并不会把内存归还给操作系统，而是缓存在malloc的内存池中，待下次使用   
- 内存大于128KB, 通过mmap()系统调用在文件映射区域分配内存  
  free释放内存的时候，会把内存归还给操作系统，内存得到真正的释放  

**在4GB物理内存的机器上，申请8G内存会怎么样**  
- 在32位操作系统，因为进程理论上最大能申请3GB大小的虚拟内存，所以直接申请8G内存，会申请失败
- 在64位 位操作系统，因为进程理论上最大能申请128TB大小的虚拟内存，即使物理内存只有4GB，申请8G内存也是没问题  
  因为申请的内存是虚拟内存，如果这块虚拟内存被访问了，要看系统有没有Swap分区  
  - 如果没有Swap分区，因为物理空间不够，进程会被操作系统杀掉，原因是OOM内存溢出
  - 如果有Swap分区，即使物理内存只有4GB，程序也能正常使用8GB的内存，进程可以正常运行

## 内存回收 ##
**回收方式**  
- 后台内存回收（kswapd）  
  在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程异步的，不会阻塞进程的执行  
- 直接内存回收（direct reclaim）  
  如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是同步的，会阻塞进程的执行  

**回收类型**  
- 文件页  
  回收干净页的方式是直接释放内存，回收脏页的方式是先写回磁盘后再释放内存
- 匿名页  
  通过Linux的Swap机制，Swap会把不常访问的内存先写到磁盘中，然后释放这些内存

**回收算法(LRU)**  
- active_list 活跃内存页链表，这里存放的是最近被访问过（活跃）的内存页  
- inactive_list 不活跃内存页链表，这里存放的是很少被访问（非活跃）的内存页  