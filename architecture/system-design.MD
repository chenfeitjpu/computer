**系统设计**
- [如何设计一个秒杀场景](#如何设计一个秒杀场景)
- [订单到了半个小时，半个小时未支付就取消](#订单到了半个小时半个小时未支付就取消)
- [如何设计一个可重入的分布式锁，用什么结构设计](#如何设计一个可重入的分布式锁用什么结构设计)
- [负载均衡的一些方案](#负载均衡的一些方案)

## 如何设计一个秒杀场景
```
整体流程
- 入口限流抗压
  - Nginx/网关层做全局限流
  - 防刷校验
- Redis原子扣减防超卖
  - Lua脚本做资格校验和原子扣减
- MQ异步落库抗峰值
  - 创建订单、落库、扣真实库存
- DB乐观锁兜底一致性
- 超时释放库存
- 幂等性
  - 资格发放和下单消费都要有幂等处理
```

## 订单到了半个小时，半个小时未支付就取消
```
消息队列(延迟/死信队列)
- 实现
  下单时发送一条延时消息，到期后检查订单状态并取消

redis(zset)
- 实现
  下单时添加超时时间(zset add)，后台定时任务扫描到期订单(zrangebyscore)，批量取消

redis(过期key监听)
- 实现
  监听redis key过期事件
- 缺点
  - 延迟时间长
  - 监控事件会有丢失风险

定时任务扫表
- 实现
  定时任务每N分钟执行一次，修改订单状态
- 缺点
  - 延迟时间长
  - 扫描压力大

时间轮
- 实现
  内存中维护一个环形数组，按时间进行分桶管理，订单进来，丢到相应的桶，有一个指针，循环处理每个桶
- 缺点
  - 重启即丢，进程挂了，内存数据全没了
  - 无法分布式，多实例需自己实现分片逻辑
```

## 如何设计一个可重入的分布式锁，用什么结构设计
```
设计要素
- 锁的标识符(Lock ID)：用于标识锁的唯一性
- 持有者标识(Owner ID)：线程或进程的唯一标识符，通常是线程的ID或进程的ID
- 计数器：记录当前持有锁的次数
- 过期时间：为了避免死锁，锁需要设定一个合理的超时时间

锁结构
{
  "key": "lock:resource_1",
  "value": {
    "owner": "thread_id_or_process_id",
    "count": 3,
    "expires_at": "2023-10-01T12:00:00Z"
  }
}

整体流程
- 获取锁
  - 线程调用获取锁的API，如果成功，递减count字段
- 释放锁
  - 线程在完成任务时调用释放锁的API，递减count字段
  - 如果count达到0，删除锁并释放资源
- 续约锁
  - 线程在处理过程中可以根据需要续约锁
```

## 负载均衡的一些方案
```
常见方案
- DNS负载均衡
- 软件负载均衡
- 硬件负载均衡
```