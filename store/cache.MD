**缓存**
- [使用](#使用)

# 使用 #
```
指标
- 命中率  缓存命中次数/查询总次数

策略
- Cache Aside Pattern(旁路缓存模式)
  应用程序直接与DB、Cache交互，适合读多写少的业务场景，应用的前提是我们缓存的数据，是可以通过数据库进行确定性重建的，并且业务上可以容忍从‘缓存删除’到‘下一次读取并回填’之间这个极短时间窗口内的数据不一致
  - 策略
    - 写策略
      - 先更新DB，再删除Cache中的数据
    - 读策略
      - 先从Cache读取数据，如果命中(Hit)，则直接返回
      - 如果未命中(Miss)，则从DB读取数据，成功读取后，将数据写回Cache，然后返回
  - 常见问题
    - 先删Cache，后更新DB
      - 时序分析 (请求 A 写, 请求 B 读)
        - 请求 A: 先将 Cache 中的数据删除
        - 请求 B: 此时发现 Cache 为空，于是去 DB 读取旧值，并准备写入 Cache
        - 请求 A : 将新值写入 DB
        - 请求 B: 将之前读到的旧值写入了 Cache
      - 结果： DB 中是新值，而 Cache 中是旧值，数据不一致
    - 先更新 DB，后删除 Cache
      - 时序分析 (请求 A 读, 请求 B 写)
        - 请求 A : 缓存未命中，从 DB 读取到旧值
        - 请求 B: 迅速完成了 DB 的更新，并将 Cache 删除
        - 请求 A : 将自己之前拿到的旧值写入了 Cache
      - 结果： DB 中是新值，Cache 中又是旧值
    - 删除 Cache，而不是更新 Cache
      - 性能开销：写操作往往只更新了对象的部分字段，如果为了“更新 Cache”而去重新查询或计算整个缓存对象，开销可能很大。相比之下，“删除”是一个轻量级操作
      - 懒加载思想： “删除”操作遵循懒加载原则。只有当数据下一次被真正需要（被读取）时，才触发从 DB 加载并写入缓存，避免了无效的缓存更新
      - 并发安全： “更新缓存”在高并发下可能出现更新顺序错乱的问题导致脏数据的概率会更大
  - 缺陷
    - 首次请求数据一定不在 Cache 的问题
      - 对于访问量巨大的热点数据，可以在系统启动或低峰期进行缓存预热
    - 当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响
      - 数据库和缓存数据强一致场景，更新 DB 的时候同样更新 Cache，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了
      - 可以短暂地允许数据库和缓存数据不一致的场景，更新 DB 的时候同样更新 Cache，只是给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快过期，对业务的影响也是可以接受
- Read/Write Through Pattern(读/写穿透模式)
  应用程序只和Cache交互，所有的读写请求都直接打向 Cache，而 Cache 服务自身负责与 DB 进行数据同步
  - 策略
    - 读策略
      - 应用从 Cache 读取数据。如果命中，直接返回。
      - 如果未命中，由Cache 服务自己负责从 DB 加载数据，加载成功后先写入自身，再返回给应用
    - 写策略  
      - 先更新 Cache，然后 Cache 服务自己更新 DB。只有当 Cache 和 DB 都写入成功后，才向上层返回成功
  - 缺陷
    - 首次请求数据一定不在 Cache 的问题
      - 对于访问量巨大的热点数据，可以在系统启动或低峰期进行缓存预热
- Write Back Pattern(写回模式)
   应用程序只和Cache交互，所有的读写请求都直接打向 Cache，而 Cache 服务自身负责与 DB 进行数据同步，采用异步批量的方式来更新 DB。
  - 策略
    - 读策略
      - 应用从 Cache 读取数据。如果命中，直接返回。
      - 如果未命中，由Cache 服务自己负责从 DB 加载数据，加载成功后先写入自身，再返回给应用
    - 写策略 
      - 应用将数据写入 Cache，然后立即返回。
      - Cache 服务将这个写操作放入一个队列中，通过一个独立的异步线程/任务，将队列中的写操作批量地、合并地写入 DB
  - 缺陷
    - Cache 中的数据还没来得及写回 DB，系统就宕机了，会有数据一致性问题
    
常见问题
- 雪崩
  大量缓存数据在同一时间失效，导致所有请求都直接打到数据库
  - 原因
    - 大量数据同时过期
    - Redis故障宕机
  - 解决方法
    - 均匀设置过期时间
    - 服务熔断或请求限流机制
    - 构建Redis缓存高可靠集群
- 击穿
  某个热点key过期时，大量并发请求直接穿透到数据库
  - 原因
    - 某个热点数据过期了，此时大量的请求访问了该热点数据
  - 解决方法
    - 互斥锁方案，保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值
    - 永不过期 + 异步更新
- 穿透
  查询一个不存在的数据，由于缓存和数据库都没有，每次请求都会打到数据库
  - 原因
    - 业务误操作
    - 黑客恶意攻击
  - 解决方法
    - 缓存空值或者默认值
    - 非法请求的限制
    - 使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在
```
