**缓存**
- [使用](#使用)

# 使用 #
```
指标
- 命中率  缓存命中次数/查询总次数

策略
- Cache Aside(旁路缓存)
  应用程序直接与数据库、缓存交互
  - 写策略
    先更新数据库中的数据，再删除缓存中的数据
  - 读策略
    如果读取的数据命中了缓存，则直接返回数据
    如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户
  - 特点
    适合读多写少的场景，不适合写多的场景，当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响
    如果业务对缓存命中率有严格的要求
    - 在更新数据时更新缓存，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了
    - 在更新数据时更新缓存，只是给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快过期，对业务的影响也是可以接受
- Read/Write Through(读/写穿)
  应用程序只和缓存交互，不再和数据库交互，而是由缓存和数据库交互，相当于更新数据库的操作由缓存自己代理了
  - 读策略
    先查询缓存中数据是否存在，如果存在则直接返回，如果不存在，则由缓存组件负责从数据库查询数据，并将结果写入到缓存组件，最后缓存组件将数据返回给应用
  - 写策略  
    先查询缓存中是否已经存在，如果存在，则更新缓存中的数据，并且由缓存组件同步更新到数据库中，然后缓存组件告知应用程序更新完成
    如果缓存中数据不存在，直接更新数据库，然后返回
- Write Back(写回)
  适合写多的场景
  - 读策略
    先查询缓存中数据是否存在，如果存在则直接返回，如果不存在，则由缓存组件负责从数据库查询数据，并将结果写入到缓存组件，最后缓存组件将数据返回给应用
  - 写策略 
    在更新数据的时候，只更新缓存，同时将缓存数据设置为脏的，然后立马返回，并不会更新数据库。对于数据库的更新，会通过批量异步更新的方式进行

常见问题
- 雪崩
  - 原因
    - 大量数据同时过期
    - Redis故障宕机
  - 解决方法
    - 均匀设置过期时间
    - 服务熔断或请求限流机制
    - 构建Redis缓存高可靠集群
- 击穿
  - 原因
    - 某个热点数据过期了，此时大量的请求访问了该热点数据
  - 解决方法
    - 互斥锁方案，保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值
    - 不给热点数据设置过期时间
- 穿透
  - 原因
    - 业务误操作
    - 黑客恶意攻击
  - 解决方法
    - 缓存空值或者默认值
    - 非法请求的限制
    - 使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在

一致性保证
- 先更新数据库，再更新缓存
- 先更新缓存，再更新数据库
- 先删除缓存，再更新数据库
- 先更新数据库，再删除缓存
```
