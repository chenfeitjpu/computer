**TCP**
- [简介](#简介)
- [数据格式](#数据格式)
- [连接管理](#连接管理)
- [可靠性保证](#可靠性保证)
- [常见问题](#常见问题)

## 简介
```
面向连接、可靠的、基于字节流的传输层通信协议
```

## 数据格式
```
头部格式
- 源端口号
- 目标端口号
- 序列号  当前数据包编号
- 确认应答号  下一次期望收到的序列号
- 控制位
  - SYN  建立连接
  - ACK  确认应答
  - FIN  断开连接
  - RST  强制断开连接
```

## 连接管理
```
三次握手
- 流程  
  - 服务端(CLOSED状态)主动监听端口(LISTEN状态)  
  - 客户端(CLOSED状态)发送SYN报文(SYN_SENT状态)  
  - 服务端(Listend状态)发送SYN_ACK报文(SYN_RCVD状态)  
  - 客户端(SYN_SENT状态)发送ACK报文(ESTABLISHED状态)  
  - 服务端(SYN_RVCD状态)收到ACK报文(ESTABLISHED状态)   
- 为什么是三次  
  - 同步双方初始序列号
  - 避免重复连接
  - 避免历史连接
- 握手丢失
  - 第一次握手丢失  客户端超时重传SYN报文，达到最大重传次数，等待一段时间，客户端断开连接
  - 第二次握手丢失  客户端超时重传SYN报文，达到最大重传次数，等待一段时间，客户端断开连接，服务端超时重传SYN-ACK报文，达到最大重传次数，等待一段时间，服务端断开连接
  - 第三次握手丢失  服务端超时重传SYN-ACK报文，达到最大重传次数，等待一段时间，服务端断开连接，向客户端发送RST报文

连接队列
- 分类   
  - 半连接队列，也称syn队列
  - 全连接队列，也称accept队列  
- 流程  
  - 当服务端接收到客户端的SYN报文时，会创建一个半连接的对象，然后将其加入到内核的「SYN队列」
  - 接着发送SYN+ACK给客户端，等待客户端回应ACK报文
  - 服务端接收到ACK报文后，从「SYN队列」取出一个半连接对象，然后创建一个新的连接对象放入到「Accept队列」
  - 应用通过调用accpet()socket接口，从「Accept队列」取出连接对象。
- SYN攻击  
  把TCP半连接队列打满，这样当TCP半连接队列满了，后续再在收到SYN报文就会丢弃，导致客户端无法和服务端建立连接
  - 避免SYN攻击方式
    - 开启tcp_syncookies，不使用syn队列
    - 增大TCP半连接队列
    - 减少SYN+ACK重传次数，尽早断开连接
    
四次挥手
- 流程
  - 客户端(ESTABLISHED状态)发送FIN报文(FIN_WAIT_1状态)  
  - 服务端(ESTABLISHED状态)发送ACK报文(CLOSED_WAIT状态)  
  - 客户端(FIN_WAIT_1状态)接收ACK报文(FIN_WAIT_2状态)  
  - 服务端(CLOSED_WAIT状态)发送FIN报文(LAST_ACK状态)    
  - 客户端(FIN_WAIT_2状态)发送ACK报文(TIME_WAIT状态)  
  - 服务端(LAST_ACK状态)接收ACK报文(CLOSED状态)  
  - 客户端(TIME_WAIT状态)经过2MSL报文最大生存时间(CLOSED状态)  
- 为什么是四次  
  四次可以确保客户端和服务端正确关闭连接
- 挥手丢失
  - 第一次挥手丢失  客户端超时重传FIN报文，达到最大重传次数，等待一段时间，客户端断开连接
  - 第二次挥手丢失  客户端超时重传FIN报文，达到最大重传次数，等待一段时间，客户端断开连接
  - 第三次挥手丢失  服务端超时重传FIN报文，达到最大重传次数，等待一段时间，服务端断开连接，客户端在指定时间内还是没能收到服务端的第三次挥手，那么客户端就会断开连接
  - 第四次挥手丢失  服务端超时重传FIN报文，达到最大重传次数，等待一段时间，服务端断开连接，客户端等待2MSL时长，客户端断开连接
- time-wait
  - 为什么需要TIME_WAIT状态
    - 保证被动关闭连接的一方，能被正确的关闭
  - 为什么TIME_WAIT状态需要经过2MSL
    - 保证ACK不丢失
  - time-wait过多有什么危害
    - 占用系统资源
    - 占用端口资源  
  - 服务器出现大量time_wait状态的原因有哪些
    - HTTP没有使用长连接
    - HTTP长连接超时
    - HTTP长连接的请求数量达到上限

保活机制
内核级机制，如果TCP连接一直没有数据交互，达到了触发TCP保活机制的条件，内核就会发送探测报送来确定对方是否存活
```

## 可靠性保证
```
重传机制
- 超时重传
  - 数据包丢失
  - 确认应答丢失
- 快速重传  收到三个相同的ACK报文时
- SACK(选择性确认)  将已收到的数据的信息发送给发送方

流量控制
TCP提供一种机制可以让发送方根据接收方的实际接收能力控制发送的数据量，这就是所谓的流量控制
- 滑动窗口
  - 发送窗口  无需等待确认应答，可以继续发送数据的最大值
  - 接收窗口  无需等待读取，可以继续接收的数据的最大值

拥塞控制
根据网络实际承载能力，动态控制发送速度
- 拥塞窗口  根据网络的拥塞程度动态设置发送数据的大小
- 实际发送窗口  min(拥塞窗口, 接收端窗口)
```

## 常见问题
```
粘包 & 拆包
- 粘包
  发送端连续发送多条消息，接收端一次就读完了
- 拆包
  发送端的一条消息在接收端被拆成多次才读完
- 解决  应用层自己定义消息边界
  - 固定长度消息  每条消息长度固定，如 128 字节
  - 分隔符结尾  如每条消息以 \n、\r\n 结束（HTTP 请求行、Redis 协议等）
  - 长度前缀
    消息格式：[长度字段][消息体]
    
TCP&UDP
- 对比
  - TCP为应用提供可靠的字节流服务
  - UDP为应用提供尽力而为的数据报投递
- 应用场景
  - TCP(可靠性)  HTTP、FTP
  - UDP(高效率)  DNS、音频、视频等多媒体通信
```
