**TCP**
- [定义](#定义)
- [内容](#内容)

# 定义 #
```
面向连接、可靠的、基于字节流的传输层通信协议
```

# 内容 #
```
头部格式
- 源端口号
- 目标端口号
- 序列号  当前数据包编号
- 确认应答号  下一次期望收到的序列号
- 控制位
  - SYN  建立连接
  - ACK  确认应答
  - FIN  断开连接
  - RST  强制断开连接

连接
- Socket  由IP地址和端口号组成
- 序列号  用来解决乱序问题
- 窗口大小  用来做流量控制

三次握手
- 流程 
  - 服务端(CLOSED状态)主动监听端口(LISTEN状态)  
  - 客户端(CLOSED状态)发送SYN报文(SYN_SENT状态)  
  - 服务端(Listend状态)发送SYN_ACK报文(SYN_RCVD状态)  
  - 客户端(SYN_SENT状态)发送ACK报文(ESTABLISHED状态)  
  - 服务端(SYN_RVCD状态)收到ACK报文(ESTABLISHED状态)  
- 为什么是三次  
  - 同步双方初始序列号
  - 避免历史连接
  - 避免重复连接
- 握手丢失
  - 第一次握手丢失  
    客户端超时重传SYN报文，达到最大重传次数，等待一段时间，客户端断开连接
  - 第二次握手丢失  
    客户端超时重传SYN报文，达到最大重传次数，等待一段时间，客户端断开连接  
    服务端超时重传SYN-ACK报文，达到最大重传次数，等待一段时间，服务端断开连接
  - 第三次握手丢失  
    服务端超时重传SYN-ACK报文，达到最大重传次数，等待一段时间，服务端断开连接，向客户端发送RST报文
    队列
- 连接队列
  - 分类   
    - 半连接队列，也称syn队列
    - 全连接队列，也称accept队列  
  - 流程  
    - 当服务端接收到客户端的SYN报文时，会创建一个半连接的对象，然后将其加入到内核的「SYN队列」
    - 接着发送SYN+ACK给客户端，等待客户端回应ACK报文
    - 服务端接收到ACK报文后，从「SYN队列」取出一个半连接对象，然后创建一个新的连接对象放入到「Accept队列」
    - 应用通过调用accpet()socket 接口，从「Accept队列」取出连接对象。
  - SYN攻击  
    把TCP半连接队列打满，这样当TCP半连接队列满了，后续再在收到SYN报文就会丢弃，导致客户端无法和服务端建立连接
    - 避免SYN攻击方式
      - 调大netdev_max_backlog，网卡接收更多的数据包
      - 增大TCP半连接队列
      - 开启tcp_syncookies，不使用syn队列
      - 减少SYN+ACK重传次数，尽早断开连接

四次挥手
- 流程
  - 客户端(ESTABLISHED状态)发送FIN报文(FIN_WAIT_1状态)  
  - 服务端(ESTABLISHED状态)发送ACK报文(CLOSED_WAIT状态)  
  - 客户端(FIN_WAIT_1状态)接收ACK报文(FIN_WAIT_2状态)  
  - 服务端(CLOSED_WAIT状态)发送FIN报文(LAST_ACK状态)    
  - 客户端(FIN_WAIT_2状态)发送ACK报文(TIME_WAIT状态)  
  - 服务端(LAST_ACK状态)接收ACK报文(CLOSED状态)  
  - 客户端(TIME_WAIT状态)经过2MSL报文最大生存时间(CLOSED状态)  
- 为什么是四次  
  四次可以确保客户端和服务端正确关闭连接
- 挥手丢失
  - 第一次挥手丢失  
    客户端超时重传FIN报文，达到最大重传次数，等待一段时间，客户端断开连接
  - 第二次挥手丢失  
    客户端超时重传FIN报文，达到最大重传次数，等待一段时间，客户端断开连接
  - 第三次挥手丢失  
    服务端超时重传FIN报文，达到最大重传次数，等待一段时间，服务端断开连接  
    客户端因为是通过close函数关闭连接的，处于FIN_WAIT_2 状态是有时长限制的，如果tcp_fin_timeout时间内还是没能收到服务端的第三次挥手，那么客户端就会断开连接
  - 第四次挥手丢失  
    服务端超时重传FIN报文，达到最大重传次数，等待一段时间，服务端断开连接  
    客户端等待2MSL时长，客户端断开连接
- time-wait
  - 为什么需要TIME_WAIT状态
    - 保证被动关闭连接的一方，能被正确的关闭
  - 为什么TIME_WAIT状态需要经过2MSL
    - 保证ACK不丢失
  - time-wait过多有什么危害
    - 占用系统资源
    - 占用端口资源  
  - 服务器出现大量time_wait状态的原因有哪些
    - HTTP没有使用长连接
    - HTTP长连接超时
    - HTTP长连接的请求数量达到上限

重传机制
- 超时重传  超过指定的时间(RTO)
  - 数据包丢失
  - 确认应答丢失
- 快速重传  收到三个相同的ACK报文时
- SACK(选择性确认)  只重传丢失的数据
- D-SACK  使用了SACK来告诉「发送方」有哪些数据被重复接收了   

滑动窗口
- 发送方窗口  
  - 已发送并收到ACK确认的数据  
  - 已发送但未收到ACK确认的数据  
  - 未发送但总大小在接收方处理范围内
  - 未发送但总大小超过接收方处理范围  
- 接收方窗口  
  - 已成功接收并被应用程序读取的数据
  - 已成功接收并确认的数据
  - 未收到数据但可以接收的数据
  - 未收到数据并不可以接收的数据
- 流量控制
  TCP提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制  
  - 窗口为零
    如果窗口大小为0时，就会阻止发送方给接收方传递数据，直到窗口变为非0为止，这就是窗口关闭
    - TCP为每个连接设有一个持续定时器，只要TCP连接一方收到对方的零窗口通知，就启动持续计时器，如果持续计时器超时，就会发送窗口探测报文，而对方在确认这个探测报文时，给出自己现在的接收窗口大小
  - 糊涂窗口综合症
    - 接收方避免通告小窗口
      当窗口大小小于MSS时，就会向发送方通告窗口为0，也就阻止了发送方再发数据过来  
      等到接收方处理了一些数据后，窗口大小>=MSS，就可以把窗口打开让发送方发送数据过来
    - 发送方避免发送小数据
      - 要等到窗口大小>=MSS并且数据大小>=MSS
      - 收到之前发送数据的ack包
- 拥塞控制
  - 慢启动
    当发送方每收到一个ACK，拥塞窗口cwnd的大小就会加1
  - 拥塞避免
    当拥塞窗口cwnd超过慢启动门限ssthresh就会进入拥塞避免算法
    每当收到一个ACK时，cwnd增加1/cwnd
  - 拥塞发生
    - 发生超时重传的拥塞发生算法
      - ssthresh设为cwnd/2
      - cwnd重置为初始化值
    - 发生快速重传的拥塞发生算法
      - cwnd=cwnd/2
      - ssthresh = cwnd
      - 进入快速恢复算法
  - 快速恢复
    - 拥塞窗口cwnd=ssthresh+3
    - 重传丢失的数据包，如果再收到重复的ACK，那么cwnd增加1，如果收到新数据的ACK后，把cwnd设置为第一步中的ssthresh的值，再次进入拥塞避免状态

保活机制
如果两端的TCP连接一直没有数据交互，达到了触发TCP保活机制的条件，就会发送探测报送来确定对方的TCP连接是否存活

TCP&UDP
- 区别
  - 连接
    TCP是面向连接的传输层协议，传输数据前先要建立连接
    UDP是不需要连接，即刻传输数据
  - 服务对象
    TCP是一对一的两点服务，即一条连接只有两个端点
    UDP支持一对一、一对多、多对多的交互通信
  - 可靠性
    TCP是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达
    UDP是尽最大努力交付，不保证可靠交付数据
  - 传输效率
    TCP有拥塞控制和流量控制，控制数据传输效率
    UDP则没有，即使网络非常拥堵了，也不会影响UDP的发送速率
  - 传输方式
    TCP是流式传输，没有边界，但保证顺序和可靠
    UDP是一个包一个包的发送，是有边界的，但可能会丢包和乱序
  - 分片不同
    TCP的数据大小如果大于 MSS 大小，则会在传输层进行分片
    UDP的数据大小如果大于 MTU 大小，则会在 IP 层进行分片
- 应用场景
  - TCP(可靠性)
    HTTP、TCP
  - UDP(高效率)
    DNS、视频、音频等多媒体通信
```