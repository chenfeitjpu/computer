**TCP**
- [定义](#定义)
- [内容](#内容)
  - [数据格式](#数据格式)
  - [连接管理](#连接管理)
  - [可靠性保证](#可靠性保证)
  - [常见问题](#常见问题)

# 定义 #
```
面向连接、可靠的、基于字节流的传输层通信协议
```

# 内容 #
## 数据格式 ##
```
头部格式
- 源端口号
- 目标端口号
- 序列号  当前数据包编号
- 确认应答号  下一次期望收到的序列号
- 控制位
  - SYN  建立连接
  - ACK  确认应答
  - FIN  断开连接
  - RST  强制断开连接
```

## 连接管理 ##
```
三次握手
- 流程  
  - 服务端(CLOSED状态)主动监听端口(LISTEN状态)  
  - 客户端(CLOSED状态)发送SYN报文(SYN_SENT状态)  
  - 服务端(Listend状态)发送SYN_ACK报文(SYN_RCVD状态)  
  - 客户端(SYN_SENT状态)发送ACK报文(ESTABLISHED状态)  
  - 服务端(SYN_RVCD状态)收到ACK报文(ESTABLISHED状态)   
- 为什么是三次  
  - 同步双方初始序列号
  - 避免重复连接
  - 避免历史连接
- 握手丢失
  - 第一次握手丢失  客户端超时重传SYN报文，达到最大重传次数，等待一段时间，客户端断开连接
  - 第二次握手丢失  客户端超时重传SYN报文，达到最大重传次数，等待一段时间，客户端断开连接，服务端超时重传SYN-ACK报文，达到最大重传次数，等待一段时间，服务端断开连接
  - 第三次握手丢失  服务端超时重传SYN-ACK报文，达到最大重传次数，等待一段时间，服务端断开连接，向客户端发送RST报文

连接队列
- 分类   
  - 半连接队列，也称syn队列
  - 全连接队列，也称accept队列  
- 流程  
  - 当服务端接收到客户端的SYN报文时，会创建一个半连接的对象，然后将其加入到内核的「SYN队列」
  - 接着发送SYN+ACK给客户端，等待客户端回应ACK报文
  - 服务端接收到ACK报文后，从「SYN队列」取出一个半连接对象，然后创建一个新的连接对象放入到「Accept队列」
  - 应用通过调用accpet()socket接口，从「Accept队列」取出连接对象。
- SYN攻击  
  把TCP半连接队列打满，这样当TCP半连接队列满了，后续再在收到SYN报文就会丢弃，导致客户端无法和服务端建立连接
  - 避免SYN攻击方式
    - 开启tcp_syncookies，不使用syn队列
    - 增大TCP半连接队列
    - 减少SYN+ACK重传次数，尽早断开连接
    
四次挥手
- 流程
  - 客户端(ESTABLISHED状态)发送FIN报文(FIN_WAIT_1状态)  
  - 服务端(ESTABLISHED状态)发送ACK报文(CLOSED_WAIT状态)  
  - 客户端(FIN_WAIT_1状态)接收ACK报文(FIN_WAIT_2状态)  
  - 服务端(CLOSED_WAIT状态)发送FIN报文(LAST_ACK状态)    
  - 客户端(FIN_WAIT_2状态)发送ACK报文(TIME_WAIT状态)  
  - 服务端(LAST_ACK状态)接收ACK报文(CLOSED状态)  
  - 客户端(TIME_WAIT状态)经过2MSL报文最大生存时间(CLOSED状态)  
- 为什么是四次  
  四次可以确保客户端和服务端正确关闭连接
- 挥手丢失
  - 第一次挥手丢失  客户端超时重传FIN报文，达到最大重传次数，等待一段时间，客户端断开连接
  - 第二次挥手丢失  客户端超时重传FIN报文，达到最大重传次数，等待一段时间，客户端断开连接
  - 第三次挥手丢失  服务端超时重传FIN报文，达到最大重传次数，等待一段时间，服务端断开连接，客户端在指定时间内还是没能收到服务端的第三次挥手，那么客户端就会断开连接
  - 第四次挥手丢失  
    服务端超时重传FIN报文，达到最大重传次数，等待一段时间，服务端断开连接，客户端等待2MSL时长，客户端断开连接
- time-wait
  - 为什么需要TIME_WAIT状态
    - 保证被动关闭连接的一方，能被正确的关闭
  - 为什么TIME_WAIT状态需要经过2MSL
    - 保证ACK不丢失
  - time-wait过多有什么危害
    - 占用系统资源
    - 占用端口资源  
  - 服务器出现大量time_wait状态的原因有哪些
    - HTTP没有使用长连接
    - HTTP长连接超时
    - HTTP长连接的请求数量达到上限

保活机制
如果两端的TCP连接一直没有数据交互，达到了触发TCP保活机制的条件，就会发送探测报送来确定对方的TCP连接是否存活
```

## 可靠性保证 ##
```
重传机制
- 超时重传
  - 数据包丢失
  - 确认应答丢失
- 快速重传  收到三个相同的ACK报文时
- SACK(选择性确认)  将已收到的数据的信息发送给发送方

流量控制
TCP提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制
- 滑动窗口
  窗口大小就是无需等待确认应答，可以继续发送数据的最大值
- 发送方窗口  
  - 已发送并收到ACK确认的数据  
  - 已发送但未收到ACK确认的数据  
  - 未发送但总大小在接收方处理范围内
  - 未发送但总大小超过接收方处理范围  
- 接收方窗口  
  - 已成功接收并被应用程序读取的数据
  - 已成功接收并确认的数据
  - 未收到数据但可以接收的数据
  - 未收到数据并不可以接收的数据

拥塞控制
根据网络实际承载能力，动态控制发送速度
- 拥塞窗口  根据网络的拥塞程度动态设置发送数据的大小
- 实际发送窗口  min(拥塞窗口, 接收端窗口)
```

## 常见问题  ##
```
粘包 & 拆包
- 粘包
  发送端连续发送多条消息，接收端一次就读完了
- 拆包
  发送端的一条消息在接收端被拆成多次才读完
- 解决  应用层自己定义消息边界
  - 固定长度消息  每条消息长度固定，如 128 字节
  - 分隔符结尾  如每条消息以 \n、\r\n 结束（HTTP 请求行、Redis 协议等）
  - 长度前缀
    消息格式：[长度字段][消息体]
    
TCP&UDP
- 对比
  - 连接
    TCP是面向连接的传输层协议，传输数据前先要建立连接
    UDP是不需要连接，即刻传输数据
  - 服务对象
    TCP是一对一的两点服务，即一条连接只有两个端点
    UDP支持一对一、一对多、多对多的交互通信
  - 可靠性
    TCP是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达
    UDP是尽最大努力交付，不保证可靠交付数据
  - 传输方式
    TCP是流式传输，没有边界
    UDP是一个包一个包的发送，是有边界的
  - 传输效率
    TCP有流量控制和拥塞控制，控制数据传输效率
    UDP则没有，即使网络非常拥堵了，也不会影响UDP的发送速率
  - 分片不同
    TCP的数据大小如果大于 MSS 大小，则会在传输层进行分片
    UDP的数据大小如果大于 MTU 大小，则会在IP层进行分片
- 应用场景
  - TCP(可靠性)  HTTP、FTP
  - UDP(高效率)  DNS、音频、视频等多媒体通信
```