**TCP**
- [定义](#定义)
- [内容](#内容)
  - [头部格式](#头部格式)
  - [连接](#连接)
  - [三次握手](#三次握手)
  - [SYN攻击](#syn攻击)
  - [四次挥手](#四次挥手)
  - [重传机制](#重传机制)
  - [滑动窗口](#滑动窗口)
  - [流量控制](#流量控制)
  - [拥塞控制](#拥塞控制)

# 定义 #
面向连接、可靠的、基于字节流的传输层通信协议

# 内容 #
## 头部格式 ##
![](./images/tcp_head_structure.webp)
- 源端口号
- 目标端口号
- 序列号 当前数据包编号
- 确认应答号 下一次期望收到的序列号
- 控制位
  - SYN 建立连接
  - ACK 确认应答
  - FIN 断开连接
  - RST 强制断开连接
 
## 连接 ##
![](./images/tcp_connection_structure.webp)

- Socket 由IP地址和端口号组成
- 序列号 用来解决乱序问题等
- 窗口大小 用来做流量控制

## 三次握手 ##
**流程**  
1.服务端(CLOSED状态)主动监听端口(LISTEN状态)  
2.客户端(CLOSED状态)发送SYN报文(SYN_SENT状态)  
3.服务端(Listend状态)发送SYN_ACK报文(SYN_RCVD状态)  
4.客户端(SYN_SENT状态)发送ACK报文(ESTABLISHED状态)  
5.服务端(SYN_RVCD状态)收到ACK报文(ESTABLISHED状态)  

**为什么是三次**  
- 同步初始序列号 两次只能同步发送方的序列号  
- 防止重复建立连接 两次无法阻止服务端建立重复连接  

## SYN攻击 ##  
![](./images/tcp_syn_accept_queue.webp)

**队列**
- 半连接队列，也称 SYN 队列
- 全连接队列，也称 accept 队列  

**流程**  
- 当服务端接收到客户端的 SYN 报文时，会创建一个半连接的对象，然后将其加入到内核的「 SYN 队列」
- 接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文
- 服务端接收到 ACK 报文后，从「 SYN 队列」取出一个半连接对象，然后创建一个新的连接对象放入到「 Accept 队列」
- 应用通过调用 accpet() socket 接口，从「 Accept 队列」取出连接对象。

**避免SYN攻击方式**  
- 调大 netdev_max_backlog
- 增大 TCP 半连接队列
- 开启 tcp_syncookies
- 减少 SYN+ACK 重传次数

## 四次挥手 ##
**流程**  
1.客户端(ESTABLISHED状态)发送FIN报文(FIN_WAIT_1状态)  
2.服务端(ESTABLISHED状态)发送ACK报文(CLOSED_WAIT状态)  
3.客户端(FIN_WAIT_1状态)接收ACK报文(FIN_WAIT_2状态)  
4.服务端(CLOSED_WAIT状态)发送FIN报文(LAST_ACK状态)    
5.客户端(FIN_WAIT_2状态)发送ACK报文(TIME_WAIT状态)  
6.服务端(LAST_ACK状态)接收ACK报文(CLOSED状态)  
7.客户端(TIME_WAIT状态)经过2MSL(CLOSED状态)  

**为什么是四次**  
四次可以确保客户端和服务端正确关闭连接

**为什么需要TIME_WAIT状态**  
- 防止历史连接中的数据，被后面相同四元组的连接错误的接收
- 保证「被动关闭连接」的一方，能被正确的关闭

## 重传机制 ##
- 超时重传  超过指定的时间(RTO)
  - 数据包丢失
  - 确认应答丢失
- 快速重传 收到三个相同的ACK报文时
- SACK(选择性确认) 只重传丢失的数据
- D-SACK 使用了 SACK 来告诉「发送方」有哪些数据被重复接收了   

## 滑动窗口 ##
**发送方窗口**  
#1 已发送并收到ACK确认的数据  
#2 已发送但未收到ACK确认的数据(SND.UNA)  
#3 未发送但总大小在接收方处理范围内(SND.NXT)  
#4 未发送但总大小超过接收方处理范围  

**接收方窗口**  
#1 已成功接收并确认的数据  
#2 未收到数据但可以接收的数据(RCV.NXT)  
#3 未收到数据并不可以接收的数据

## 流量控制 ##
TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制

## 拥塞控制 ##
- 慢启动
- 拥塞避免算法
- 拥塞发生
- 快速恢复

